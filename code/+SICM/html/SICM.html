
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>SICM namespace documentation</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-12-21"><meta name="DC.source" content="SICM.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>SICM namespace documentation</h1><!--introduction--><p>The namespace SICM provides tools to handle, analyze and process SICM data. There are several (outdated) functions in this namespace which will not be documented (but the function may or may not be documented), as well as some classes. One should use the classes.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Classes in the namespace</a></li><li><a href="#2">General remarks</a></li><li><a href="#12">Common methods</a></li><li><a href="#14">Which data can be imported and how can data import be extended?</a></li><li><a href="#15">Extended functionality, code guidelines</a></li><li><a href="#16">Example for extending a class</a></li></ul></div><h2>Classes in the namespace<a name="1"></a></h2><p>The following classes are provided by this collection. You can try to click on the links below, however, they might not be documented as publishable files, hence linking might not work.</p><div><ul><li><a href="MATLAB:SICM.SICMAPPCURVE">SICM.SICMAppCurve</a></li><li><a href="MATLAB:SICM.SICMSCAN">SICM.SICMScan</a></li></ul></div><h2>General remarks<a name="2"></a></h2><p>The following information is for the two classes listed above. They share some principles which are briefly listed here. The first is how to generate an object of one of the classes. The simplest way is to simply generate such an object calling the constructor of the class. Note that the prefix <tt>SICM.</tt> is required since the classes reside in the namspace SICM.</p><pre class="codeinput">scan = SICM.SICMScan();
</pre><p>However, this results in an empty SICMSCan-object. While this might be desired in some special cases, in most cases you want to load data from an experiment into such a class. For this purpose, both classes are equipped with static functions, which allow generating objects from data. The most common static method is <tt>FromFile</tt>, which can be either called with a filename as argument or without an argument, which will open a file selection dialog</p><pre class="language-matlab">scan = SICM.SICMScan.FromFile();
</pre><p><i>(Todo: If you click cancel in the file selection dialog, an error will occur. This should be fixed.)</i></p><p>Both classes provide a number of methods that allow manipulating the data. However, there is no undo-function in Matlab, hence it is worth copying the object before changing the data. However, note the following. Let's create an SICMSCan-object with exemplary data</p><pre class="codeinput">scan = SICM.SICMScan.FromExampleData();
</pre><p>The volume of the scan can be received by the method <tt>volume()</tt>:</p><pre class="codeinput">scan.volume()
</pre><pre class="codeoutput">
ans =

   1.3937e+05

</pre><p>Lets now copy the scan object</p><pre class="codeinput">scan2 = scan;
scan2.volume()
</pre><pre class="codeoutput">
ans =

   1.3937e+05

</pre><p>Of course, <tt>scan2</tt> has the same volume as <tt>scan</tt> since they are copies. Now, let's manipulate the x-size of <tt>scan2</tt></p><pre class="codeinput">scan2.setXSize(25);
</pre><p>Since now the pixel width in one direction has changed, the volume has changed, too:</p><pre class="codeinput">scan2.volume()
</pre><pre class="codeoutput">
ans =

   6.9684e+04

</pre><p>But if we look at the volme of <tt>scan</tt></p><pre class="codeinput">scan.volume()
</pre><pre class="codeoutput">
ans =

   6.9684e+04

</pre><p>we see that its volume has changed, too. This is due to the way Matlab implements object oriented programming. To avoid <a href="http://undocumentedmatlab.com/blog/internal-matlab-memory-optimizations">lazy copying</a>, the classes in this namespace are derived from the <a href="matlab:HANDLE">handle</a> class, which results in this behaviour. Hence, nearly every method that manipulates data detects whether an output argumnt is requested, an in this case make a true copy of the original object, which is in turn manipulated and returned. For the example above:</p><pre class="codeinput">scan = SICM.SICMScan.FromExampleData();
scan2 = scan.setXSize(25);
scan2.volume()
</pre><pre class="codeoutput">
ans =

   6.9684e+04

</pre><pre class="codeinput">scan.volume()
</pre><pre class="codeoutput">
ans =

   1.3937e+05

</pre><h2>Common methods<a name="12"></a></h2><p>Both classes share the method <tt>plot</tt> to quickly show the data. Hence, to see the effect of a data manipulation, one can do the following:</p><pre class="codeinput">figure(<span class="string">'Position'</span>,[30 30 800 375]);
scan = SICM.SICMScan.FromExampleData();
subplot(1,2,1);
plot(scan); title(<span class="string">'raw data'</span>);
axis <span class="string">tight</span>, view(-15, 70);
scan2 = scan.flatten(<span class="string">'linewise'</span>);
subplot(1,2,2);
plot(scan2); title(<span class="string">'flattened data'</span>);
axis <span class="string">tight</span>, view(-15, 70);
colormap(hot);
</pre><img vspace="5" hspace="5" src="SICM_01.png" alt=""> <p>For the class <tt>SICMScan</tt>, the plot method has on additional argument which allows interpolation:</p><pre class="codeinput">clf;
subplot(1,2,1);
plot(scan2); title(<span class="string">'flattened data'</span>);
axis <span class="string">tight</span>, view(-15, 70);
subplot(1,2,2);
plot(scan2,10); title(<span class="string">'interpolated flattened data'</span>);
axis <span class="string">tight</span>, view(-15, 70);
colormap(hot);
</pre><img vspace="5" hspace="5" src="SICM_02.png" alt=""> <h2>Which data can be imported and how can data import be extended?<a name="14"></a></h2><p>Data importing is in my opinion one of the most annoying things when handling SICM data. To simplify this, the class <tt>importer</tt> resides in this namespace, too, and the SICM data classes inherit from it. The importer class provides (besides an empty constructor) only two functions: <tt>getFilename_</tt> and <tt>getObjectFromFilename_</tt>. The first function is responsible for the correct file selection dialog, the second for opening the data file and returning the respective object.</p><p>However, the information which data can be processed and how it is imported still has to be provided to the class. The derived classes have a constant property called <tt>importers</tt> which is a cell array conatining the importers known for this class. An <i>importer</i> in this case is a struct that conatins the following:</p><p>
<table>
<thead>
<tr>
<th>fieldname</th><th>content</th>
</tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td>A name identifying ans explaining the
importer</td></tr>
<tr><td><code>exts</code></td><td>A string containing the file extensions that can be handled by this import (as requested by the uigetfile function).</td></tr>
<tr><td><code>expl</code></td><td>A string describing the file types (as requested
by the uigetfile function).</td></tr>
<tr><td><code>extlist</code></td><td>A cell containing the extensione, including the
leading dot, for easier parsing with strcmp</td></tr>
<tr><td><code>handle</code></td><td>A handle to a function that imports the data and
returns the object</td></tr>
</tbody>
</table>
</p><p>For example, the importer struct to import <tt>.sic</tt> or <tt>.ras</tt> files looks like this:</p><pre class="language-matlab">struct(<span class="keyword">...</span>
    <span class="string">'name'</span>   , <span class="string">'ASCII data import, PH'</span>, <span class="keyword">...</span>
    <span class="string">'exts'</span>   , <span class="string">'*.sic; *.ras;'</span>,<span class="keyword">...</span>
    <span class="string">'expl'</span>   , <span class="string">'ASCII data files (*.sic, *.ras)'</span>,<span class="keyword">...</span>
    <span class="string">'extlist'</span>, {{<span class="string">'.sic'</span>, <span class="string">'.ras'</span>}},<span class="keyword">...</span>
    <span class="string">'handle'</span> , @local_ReadAsciiData<span class="keyword">...</span>
)
</pre><p>To add a new importer, simply add another importer struct to the <tt>importers</tt> constant.</p><h2>Extended functionality, code guidelines<a name="15"></a></h2><p>The code of the classes is organized in files, residing in a folder starting with <tt>@</tt>, followed by the class name. Within this folder, there is a file <i>classname.m</i> which contains the properties, the constructor, the signature of the methods and, optional, local functions.</p><p>To extend a class, add the function signature to the class definition and add the corresponding function in a file in the <i>@classname</i> folder.</p><p>I suggestto follow these naming conventions:</p><p><b>static functions:</b> Should start with an uppercase letter and be CamelCased.</p><p><b>internal static functions:</b> There is no true difference between static functions and internal static functions. To indicate that the function is intended for internal use, make them start lowercase and end with and underscore (<tt>_</tt>) (Note, in many code conventions, private or internal function start with an underscore, but Matlab does not allow this, hence I suggest to add it at the end of the function name).</p><p><b>public function:</b> Should start lowercase and be CamelCased. If they manipulate the data, they should return a copy of the object instead of modyfying the object itself, when an output argument is requested.</p><p><b>private functions:</b> As internal static function</p><p><b>local functions:</b> Local helper functions should start with <tt>local_</tt>. No other conventions apply.</p><h2>Example for extending a class<a name="16"></a></h2><p>Let's add a function <tt>invert</tt> to the SICMSCan class, which inverts (multiplying by -1) the zdata of the scan (note that this function is included in the class, but it is mostly useless and just taken as an example).</p><p>Since the function manipulates the data, it should return a copied object, if requested. hence, we add the following signature to the <tt>SICMScan.m</tt> file</p><pre class="language-matlab">methods (Access = public)
<span class="comment">% ...</span>
   varargout = inverse(self);
<span class="comment">% ...</span>
<span class="keyword">end</span>
</pre><p>and add the file <tt>inverse.m</tt> to the folder <tt>@SICMScan</tt>:</p><pre class="language-matlab">
<span class="keyword">function</span> varargout = inverse(self)
<span class="comment">% This function inverses the z-data of the object.</span>
<span class="comment">%</span>
<span class="comment">% Examples:</span>
<span class="comment">%    obj.inverse()</span>
<span class="comment">%       The data of obj is inversed.</span>
<span class="comment">%</span>
<span class="comment">%    newobj = obj.inverse()</span>
<span class="comment">%</span>
<span class="comment">%    Returns a new object with the inversed data of obj. obj is not</span>
<span class="comment">%    modified.</span>

    <span class="comment">% If an output argument is specified, copy the object and call</span>
    <span class="comment">% the inverse() method of this object. Then return it and leave the</span>
    <span class="comment">% method.</span>
    <span class="keyword">if</span> nargout == 1
       o = SICM.SICMScan.fromSICMScan_(self);
       o.inverse();
       varargout{1} = o;
       <span class="keyword">return</span>
    <span class="keyword">end</span>

    <span class="comment">% now do the work:</span>
    self.multiply_(-1);
<span class="keyword">end</span>

</pre><p>Test it:</p><pre class="codeinput">scan = SICM.SICMScan.FromExampleData();
scan2 = scan.inverse();

clf;
subplot(1,2,1);
plot(scan); title(<span class="string">'raw data'</span>);
axis <span class="string">tight</span>, view(-15, 70);
subplot(1,2,2);
plot(scan2); title(<span class="string">'inversed data'</span>);
axis <span class="string">tight</span>, view(-15, 70);
colormap(hot);
</pre><img vspace="5" hspace="5" src="SICM_03.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% SICM namespace documentation
% The namespace SICM provides tools to handle, analyze and process SICM
% data. There are several (outdated) functions in this namespace which
% will not be documented (but the function may or may not be documented),
% as well as some classes. One should use the classes.
%
%% Classes in the namespace
% The following classes are provided by this collection. You can try to
% click on the links below, however, they might not be documented as
% publishable files, hence linking might not work. 
%
% * <MATLAB:SICM.SICMAPPCURVE SICM.SICMAppCurve>
% * <MATLAB:SICM.SICMSCAN SICM.SICMScan>

%% General remarks
% The following information is for the two classes listed above. They share
% some principles which are briefly listed here. The first is how to
% generate an object of one of the classes. The simplest way is to simply
% generate such an object calling the constructor of the class. Note that
% the prefix |SICM.| is required since the classes reside in the
% namspace SICM.

scan = SICM.SICMScan();
%%
% However, this results in an empty SICMSCan-object. While this might be
% desired in some special cases, in most cases you want to load data from
% an experiment into such a class. For this purpose, both classes are
% equipped with static functions, which allow generating objects from data.
% The most common static method is |FromFile|, which can be either called
% with a filename as argument or without an argument, which will open a
% file selection dialog
%
%   scan = SICM.SICMScan.FromFile();

%%
% _(Todo: If you click cancel in the file selection dialog, an error will
% occur. This should be fixed.)_
% 
% Both classes provide a number of methods that allow manipulating the
% data. However, there is no undo-function in Matlab, hence it is worth
% copying the object before changing the data. However, note the following.
% Let's create an SICMSCan-object with exemplary data

scan = SICM.SICMScan.FromExampleData();

%%
% The volume of the scan can be received by the method |volume()|:
scan.volume()

%%
% Lets now copy the scan object 
scan2 = scan;
scan2.volume()
%%
% Of course, |scan2| has the same volume as |scan| since they are copies.
% Now, let's manipulate the x-size of |scan2|
scan2.setXSize(25);
%%
% Since now the pixel width in one direction has changed, the volume has
% changed, too:
scan2.volume()
%%
% But if we look at the volme of |scan|
scan.volume()
%%
% we see that its volume has changed, too. This is due to the way Matlab
% implements object oriented programming. To avoid
% <http://undocumentedmatlab.com/blog/internal-matlab-memory-optimizations
% lazy copying>, the classes in this namespace are derived from the
% <matlab:HANDLE handle>
% class, which results in this behaviour. Hence, nearly every method that
% manipulates data detects whether an output argumnt is requested, an in
% this case make a true copy of the original object, which is in turn
% manipulated and returned. For the example above:
scan = SICM.SICMScan.FromExampleData();
scan2 = scan.setXSize(25);
scan2.volume()
%%
scan.volume()
%% Common methods
% Both classes share the method |plot| to quickly show the data. Hence, to
% see the effect of a data manipulation, one can do the following:
figure('Position',[30 30 800 375]);
scan = SICM.SICMScan.FromExampleData();
subplot(1,2,1);
plot(scan); title('raw data');
axis tight, view(-15, 70);
scan2 = scan.flatten('linewise');
subplot(1,2,2);
plot(scan2); title('flattened data');
axis tight, view(-15, 70);
colormap(hot);
%%
% For the class |SICMScan|, the plot method has on additional argument
% which allows interpolation:
clf;
subplot(1,2,1);
plot(scan2); title('flattened data');
axis tight, view(-15, 70);
subplot(1,2,2);
plot(scan2,10); title('interpolated flattened data');
axis tight, view(-15, 70);
colormap(hot);

%% Which data can be imported and how can data import be extended?
% Data importing is in my opinion one of the most annoying things when
% handling SICM data. To simplify this, the class |importer| resides in
% this namespace, too, and the SICM data classes inherit from it. The
% importer class provides (besides an empty constructor) only two functions:
% |getFilename_| and |getObjectFromFilename_|. The first function is
% responsible for the correct file selection dialog, the second for opening
% the data file and returning the respective object.
%
% However, the information which data can be processed and how it is
% imported still has to be provided to the class. The derived classes have
% a constant property called |importers| which is a cell array conatining
% the importers known for this class. An _importer_ in this case is a
% struct that conatins the following:
%
% <html>
% <table>
% <thead>
% <tr>
% <th>fieldname</th><th>content</th>
% </tr>
% </thead>
% <tbody>
% <tr><td><code>name</code></td><td>A name identifying ans explaining the
% importer</td></tr>
% <tr><td><code>exts</code></td><td>A string containing the file extensions that can be handled by this import (as requested by the uigetfile function).</td></tr>
% <tr><td><code>expl</code></td><td>A string describing the file types (as requested
% by the uigetfile function).</td></tr>
% <tr><td><code>extlist</code></td><td>A cell containing the extensione, including the
% leading dot, for easier parsing with strcmp</td></tr>
% <tr><td><code>handle</code></td><td>A handle to a function that imports the data and
% returns the object</td></tr>
% </tbody>
% </table>
% </html>
%
% For example, the importer struct to import |.sic| or |.ras| files looks
% like this:
%
%   struct(...  
%       'name'   , 'ASCII data import, PH', ...
%       'exts'   , '*.sic; *.ras;',...
%       'expl'   , 'ASCII data files (*.sic, *.ras)',...
%       'extlist', {{'.sic', '.ras'}},...
%       'handle' , @local_ReadAsciiData...
%   )
%
% To add a new importer, simply add another importer struct to the
% |importers| constant.
%
%% Extended functionality, code guidelines
% The code of the classes is organized in files, residing in a folder
% starting with |@|, followed by the class name. Within this folder, there
% is a file _classname.m_ which contains the properties, the constructor,
% the signature of the methods and, optional, local functions.
%
% To extend a class, add the function signature to the class definition and
% add the corresponding function in a file in the _@classname_ folder.
%
% I suggestto follow these naming conventions:
% 
% *static functions:* Should start with an uppercase letter and be
% CamelCased.
%
% *internal static functions:* There is no true difference between static
% functions and internal static functions. To indicate that the function is
% intended for internal use, make them start lowercase and end with and
% underscore (|_|) (Note, in many code conventions, private or internal
% function start with an underscore, but Matlab does not allow this, hence
% I suggest to add it at the end of the function name).
%
% *public function:* Should start lowercase and be CamelCased. If they
% manipulate the data, they should return a copy of the object instead of
% modyfying the object itself, when an output argument is requested.
%
% *private functions:* As internal static function
%
% *local functions:* Local helper functions should start with |local_|. No
% other conventions apply.
%
%% Example for extending a class
% Let's add a function |invert| to the SICMSCan class, which inverts
% (multiplying by -1) the zdata of the scan (note that this function is
% included in the class, but it is mostly useless and just taken as an
% example).  
%
% Since the function manipulates the data, it should return a copied
% object, if requested. hence, we add the following signature to the
% |SICMScan.m| file
%
%   methods (Access = public)
%   % ...
%      varargout = inverse(self);
%   % ...
%   end
% 
% and add the file |inverse.m| to the folder |@SICMScan|:
%
% <include>+SICM/@SICMScan/inverse.m</include>
%
% Test it:

scan = SICM.SICMScan.FromExampleData();
scan2 = scan.inverse();

clf;
subplot(1,2,1);
plot(scan); title('raw data');
axis tight, view(-15, 70);
subplot(1,2,2);
plot(scan2); title('inversed data');
axis tight, view(-15, 70);
colormap(hot);
##### SOURCE END #####
--></body></html>